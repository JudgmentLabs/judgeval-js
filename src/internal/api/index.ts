/**
 * Auto-generated by scripts/generate-client.ts
 * DO NOT EDIT MANUALLY - This file is generated automatically
 */
import * as Models from './models';

export class JudgmentApiClient {
  private baseUrl: string;
  private apiKey: string;
  private organizationId: string;

  constructor(baseUrl: string, apiKey: string, organizationId: string) {
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
    this.organizationId = organizationId;
  }

  private buildUrl(path: string): string {
    return this.baseUrl + path;
  }

  private buildHeaders(): Record<string, string> {
    if (!this.apiKey || !this.organizationId) {
      throw new Error('API key and organization ID cannot be null');
    }
    return {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${this.apiKey}`,
      'X-Organization-Id': this.organizationId,
    };
  }

  async addToRunEvalQueue(payload: Models.ExampleEvaluationRun): Promise<void> {
    const url = this.buildUrl("/add_to_run_eval_queue/");
    const response = await fetch(url, {
      method: "POST",
      headers: this.buildHeaders(),
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} - ${await response.text()}`);
    }

    return;
  }

  async logEvalResults(payload: Models.EvalResults): Promise<void> {
    const url = this.buildUrl("/log_eval_results/");
    const response = await fetch(url, {
      method: "POST",
      headers: this.buildHeaders(),
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} - ${await response.text()}`);
    }

    return;
  }

  async fetchExperimentRun(payload: Models.EvalResultsFetch): Promise<void> {
    const url = this.buildUrl("/fetch_experiment_run/");
    const response = await fetch(url, {
      method: "POST",
      headers: this.buildHeaders(),
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} - ${await response.text()}`);
    }

    return;
  }

  async getEvaluationStatus(experiment_run_id: string, project_name: string): Promise<void> {
    const queryParams = new URLSearchParams();
    queryParams.set("experiment_run_id", experiment_run_id);
    queryParams.set("project_name", project_name);
    const url = this.buildUrl("/get_evaluation_status/" + (queryParams.toString() ? '?' + queryParams.toString() : ''));
    const response = await fetch(url, {
      method: "GET",
      headers: this.buildHeaders(),
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} - ${await response.text()}`);
    }

    return;
  }

  async scorerExists(payload: Models.ScorerExistsRequest): Promise<Models.ScorerExistsResponse> {
    const url = this.buildUrl("/scorer_exists/");
    const response = await fetch(url, {
      method: "POST",
      headers: this.buildHeaders(),
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} - ${await response.text()}`);
    }

    return await response.json() as Models.ScorerExistsResponse;
  }

  async saveScorer(payload: Models.SavePromptScorerRequest): Promise<Models.SavePromptScorerResponse> {
    const url = this.buildUrl("/save_scorer/");
    const response = await fetch(url, {
      method: "POST",
      headers: this.buildHeaders(),
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} - ${await response.text()}`);
    }

    return await response.json() as Models.SavePromptScorerResponse;
  }

  async fetchScorer(payload: Models.FetchPromptScorerRequest): Promise<Models.FetchPromptScorerResponse> {
    const url = this.buildUrl("/fetch_scorer/");
    const response = await fetch(url, {
      method: "POST",
      headers: this.buildHeaders(),
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} - ${await response.text()}`);
    }

    return await response.json() as Models.FetchPromptScorerResponse;
  }

  async projectsResolve(payload: Models.ResolveProjectNameRequest): Promise<Models.ResolveProjectNameResponse> {
    const url = this.buildUrl("/projects/resolve/");
    const response = await fetch(url, {
      method: "POST",
      headers: this.buildHeaders(),
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} - ${await response.text()}`);
    }

    return await response.json() as Models.ResolveProjectNameResponse;
  }

}